---
title: "PHP 변경점 정리: 5.6부터 8.1까지"
author: haruair
type: post
date: "2022-06-26T18:32:09.126Z"
lang: ko
tags:
  - 개발 이야기
  - php
slug: "php-changes-from-56-to-81"
---

[PHP 부록](https://www.php.net/manual/en/appendices.php)에 있는 이주 문서를 읽으면서 정리했다. 완전한 번역은 아니지만 중요도가 높다고 생각되는 부분을 읽으며 정리했다. 세세한 부분이나 함수는 각각 문서를 참고하는 것을 권장한다.

## 목차

- [PHP 5.6](#php-56) (2014년 8월, [공식 문서](https://www.php.net/manual/en/migration56.php))
- [PHP 7.0](#php-70) (2015년 12월, [공식 문서](https://www.php.net/manual/en/migration70.php))
- [PHP 7.1](#php-71) (2016년 12월, [공식 문서](https://www.php.net/manual/en/migration71.php))
- [PHP 7.2](#php-72) (2017년 11월, [공식 문서](https://www.php.net/manual/en/migration72.php))
- [PHP 7.3](#php-73) (2018년 12월, [공식 문서](https://www.php.net/manual/en/migration73.php))
- [PHP 7.4](#php-74) (2019년 11월, [공식 문서](https://www.php.net/manual/en/migration74.php))
- [PHP 8.0](#php-80) (2020년 11월, [공식 문서](https://www.php.net/manual/en/migration80.php))
- [PHP 8.1](#php-81) (2021년 11월, [공식 문서](https://www.php.net/manual/en/migration81.php))

# PHP 5.6

## 호환성 문제 있는 변경

### 엄격해진 `json_decode()`

`json_decode()`에서 소문자가 아닌 `true`, `false`, `null` JSON 리터럴을 사용한 경우에는 오류가 발생하도록 변경되었다. 오류는 `json_last_error()`로 확인 가능하다.

```php
$json = '{
  "is_available": TRUE
}';
$response = json_decode($json);

json_last_error() === JSON_ERROR_SYNTAX; // true
```

## 새 기능

### 상수(constant) 표현식

숫자나 문자열 리터럴, 배열을 상수로 정의할 수 있다.

```php
const ONE = 1;
const TWO = ONE * 2;
const ARR = [ONE, TWO];

class C {
    const THREE = TWO + 1;
    const ONE_THIRD = ONE / self::THREE;
    const SENTENCE = 'The value of THREE is ' . self::THREE;

    public function f($a = ONE + self::THREE) {
        echo self::SENTENCE;
        return $a;
    }
}

echo (new C)->f(); // 4
echo C::SENTENCE; // 'The value of THREE is 3'
var_dump(ARR); // [1, 2]
```

개체도 사용할 수 있다.

```php
class Person {
    // ...
}
const ME = new Person('Edward');
var_dump(ME);
// object(Person)#1 (1) {
//   ["name":protected]=>
//   string(6) "Edward"
// }

ME = new Person('Yong');
// Parse error: syntax error, unexpected token "="
```

### `...` 연산자 (operator)

#### 함수에서 가변 인자 목록 받기

```php
function school($name, $location = null, ...$students) {
    printf('$name: %s, $location: %s, number of students: %d',
        $name, $location, count($students));
}

school('Hogwarts School', 'Scotland', 'Harry', 'Ron', 'Hermione');
// $name: Hogwarts School, $location: Scotland, number of students: 3
```

#### 인자 풀어넣기

배열이나 `Traversable` 개체를 대상으로 인자를 풀어놓을 때 `...` 연산자를 사용할 수 있다. (다른 언어에서는 splat 연산자로 지칭) 이런 문제는 `call_user_func_array()` 같은 함수로 해결했었는데 더 간단하고 깔끔하게 작성할 수 있게 되었다.

```php
function add($a, $b, $c) {
    return $a + $b + $c;
}

$nums = [2, 3];
echo add(1, ...$nums); // 6
```

### `**` 연산자로 거듭제곱하기

```php
$a = 2 ** 3; // 8
$b = 2;
$b **= 2; // 4
```

다음 연산 순서를 주의하자.

```php
$a = 2 ** 3 ** 2;
$b = (2 ** 3) ** 2;
$c = 2 ** (3 ** 2);
// $a: 512
// $b: 64
// $c: 512
```

### `use function`, `use const`

함수나 상수도 `use` 연산자로 불러 사용할 수 있다.

```php
namespace Hello\App {
    const NAME = 'hello';
    function study() { echo __FUNCTION__; }
}

namespace {
    use const Hello\App\NAME;
    use function Hello\App\study;

    echo NAME; // 'hello'
    study(); // 'Hello\App\study'
}
```

### 기본 문자열 인코딩

`htmlentities()`, `html_entity_decode()`, `htmlspecialchars()` 함수에서 기본 문자열 인코딩을 php.ini에 `default_charset` 값을 사용한다. 해당 설정은 `UTF-8`이 기본값이다.

### `hash_equals()` 시간 차 공격에 안전한 문자열 비교 함수

```php
$expected = crypt('some-password', 'some-unsafe-salt');
$correct = crypt('some-password', 'some-unsafe-salt');
$incorrect = crypt('some-wrong-password', 'some-unsafe-salt');

hash_equals($expected, $correct); // true
hash_equals($expected, $incorrect); // false
```

비밀번호 관련 함수를 사용할 수 있다면 다음처럼 작성하는 것을 권장한다.

```php
$hash = password_hash('some-password', PASSWORD_DEFAULT);

password_verify('some-password', $hash); // true
password_verify('some-wrong-password', $hash); // false
```

참고로 `password_verify()` 함수는 `crypt()` 함수의 반환값과도 사용할 수 있다.

### `__debugInfo()` 매직 메소드

클래스에 `__debugInfo()`를 정의하면 `var_dump()` 출력을 제어할 수 있다.

```php
class Person {
  private $name;
  private $secret;

  public function __construct($name, $secret) {
    $this->name = $name;
    $this->secret = $secret;
  }

  public function __debugInfo() {
    return [
      'name' => $this->name,
      'secret' => '****',
    ];
  }
}

$ed = new Person('Edward', 'have a national treasure');

var_dump($ed);
// object(Person)#1 (2) {
//   ["name"]=>
//   string(6) "Edward"
//   ["secret"]=>
//   string(4) "****"
// }
```

### 함수 변경점

- `crypt()` 함수 호출 시 `salt` 파라미터가 누락되면 **E_NOTICE**가 발생.
- `substr_compare()`에 `length` 파라미터로 `0`을 넣을 수 있음.
- `unserialize()` 함수 호출 시 생성자 호출 이전에 직렬화된 데이터를 조작한 시도가 있는 경우 직렬화에 실패하게 됨.

# PHP 7.0

## 호환성 문제 있는 변경

### 오류/예외 처리 변경

많은 수의 심각한 오류(fatal error)가 예외 처리 형태로 변경되었다. 이 오류 예외는 `Error` 클래스를 상속하며 `Throwable` 인터페이스를 구현하고 있다. 직접 구현한 핸들러가 `Exception`만 받도록 되어 있다면 `Error`를 처리하지 못해서 심각한 오류가 발생할 수 있다.

#### `set_exception_handler()`

`Throwable` 인터페이스를 활용할 수 있다. 호환성을 고려한다면 타입 선언을 제외한다.

```php
// Will break because of `Error`
function handler(Exception $e) { /* ... */ }
set_exception_handler('handler');

// PHP 5 and 7 compatible.
function handler($e) { /* ... */ }

// PHP 7 only.
function handler(Throwable $e) { /* ... */ }
```

#### `ParseError`

`eval()` 함수에서 오류가 발생한 경우 `ParseError`를 `catch`로 잡아서 처리할 수 있게 되었다.

### 변수 사용 변경점

PHP 7부터 abstract syntax tree를 사용하고 있어서 이전에 불가능한 문법을 많이 구현할 수 있게 되었다. 대신 일관성을 유지하기 위해 몇 가지 해석이 달라지는 부분도 생겼다.

```php
// 표현식
$$foo['bar']['baz']
// PHP 5 해석
${$foo['bar']['baz']}
// PHP 7+ 해석
($$foo)['bar']['baz']

// 표현식
$foo->$bar['baz']
// PHP 5 해석
$foo->{$bar['baz']}
// PHP 7+ 해석
($foo->$bar)['baz']

// 표현식
$foo->$bar['baz']()
// PHP 5 해석
$foo->{$bar['baz']}()
// PHP 7+ 해석
($foo->$bar)['baz']()

// 표현식
Foo::$bar['baz']()
// PHP 5 해석
Foo::{$bar['baz']}()
// PHP 7+ 해석
(Foo::$bar)['baz']()
```

이전과 같은 방식으로 동작하려면 `{}`를 사용해서 의미를 더 명확하게 작성해야 한다.

### `list()` 변경점

`list()` 함수는 원래 역순으로 입력했는데 이제 순서대로 입력된다. 다만 `list()` 함수의 세부 구현이 변경될 가능성이 있기 때문에 이 함수로 생성한 순서의 의존하는 구현은 권하지 않는다.

```php
list($a[], $a[], $a[]) = [1, 2, 3];
var_dump($a); // [1, 2, 3]
```

더 이상 문자열을 배열로 변환하는데 사용할 수 없다. `str_split()`을 대신 사용한다.

### `foreach` 변경점

#### `foreach`가 배열 커서를 변경하지 않음

```php
$arr = [0, 1, 2];
foreach($arr as &$val) {
  echo current($arr); // always 0
}
```

#### by-value, by-reference 동작 차이

by-value 반복은 주어진 배열을 복사해서 반복하기 때문에 길이 변화를 인식하지 못한다. 대신 by-reference 반복 중에는 배열에 추가된 항목도 인식한다.

```php
// by-value
$arr = [0];
foreach ($arr as $val) {
  var_dump($val);
  $arr[1] = 1;
}

var_dump($arr);
// int(0)
// array(2) {
//   [0]=>
//   int(0)
//   [1]=>
//   int(1)
// }
```

```php
// by-reference
$arr = [0];
foreach ($arr as &$val) {
  var_dump($val);
  $arr[1] = 1;
}
var_dump($arr);
// int(0)
// int(1) <-- 추가된 부분도 인식해서 반복 처리
// array(2) {
//   [0]=>
//   int(0)
//   [1]=>
//   int(1)
// }
```

#### `Traversable`하지 않은 개체의 반복

이런 개체는 by-reference 배열에 반복하는 것과 동일하게 처리된다.

### int 변경점

- 0으로 나누기: 이전엔 `false`가 반환되며 **E_WARNING**이 발생했는데 이제는 float으로 `+INF`, `-INF`, `NAN`이 반환되며 `DivisionByZeroError`가 발생한다.
- 음수 비트제어 오류: `1 >> -1` 등에 `ArithmeticError`가 발생한다.

### 문자열 변경점

더 이상 Hexadecimal 문자열이 숫자로 취급되지 않는다.

```php
"0x123" == "291"; // false
is_numeric("0x123"); // false
"0xe" + "0x1"; // 0
```

Hexadecimal 문자열을 정수로 변환하는 경우 `filter_var()`를 활용할 수 있다.

```php
$str = "0xffff";
$int = filter_var($str, FILTER_VALIDATE_INT, FILTER_FLAG_ALLOW_HEX);
if (false === $int) {
  throw new Exception("Invalid integer.");
}
var_dump($int); // int(65535)
```

### 그 외 변경점 (일부)

- 동일 이름 함수 파라미터 사용 시 **E_COMPILE_ERROR**
- `switch`에 여러 `default` 선언 시 **E_COMPILE_ERROR**
- `$HTTP_RAW_POST_DATA` 제거. `php://input` 스트림 사용할 것.

#### 제거된 함수

- `call_user_method()`, `call_user_method_array()`
- ereg 함수

전체 목록은 [문서 참조](https://www.php.net/manual/en/migration70.incompatible.php).

#### `yield` 우측 평가로 변경

```php
echo yield -1;
// Was previously interpreted as
echo (yield) - 1;
// And is now interpreted as
echo yield (-1);

yield $foo or die;
// Was previously interpreted as
yield ($foo or die);
// And is now interpreted as
(yield $foo) or die;
```

## 새 기능

### 스칼라 타입 선언: 강제(coercive)와 엄격(strict)

함수 파라미터에 스칼라 타입을 넣는 경우 타입 선언에 따라서 동작 방식이 달라진다. php의 기본 동작은 "강제"로 되어 있다. 강제 모드에서는 타입 힌트에 맞춰서 값이 캐스팅되지만 엄격 모드에서는 타입 힌트에 맞지 않는 경우에 오류가 발생한다.

강제 동작 방식:

```php
// coercive
// declare(strict_types=0); // 기본값임

function sumOfInts(int ...$ints)
{
  var_dump($ints);
  return array_sum($ints);
}

var_dump(sumOfInts(2, '3', 4.1));
// PHP Deprecated:  Implicit conversion from float 4.1
//        to int loses precision in app.php on line 4
// array(3) {
//   [0]=>
//   int(2)
//   [1]=>
//   int(3)
//   [2]=>
//   int(4)
// }
// int(9)
```

엄격 동작 방식:

```php
// strict
declare(strict_types=1);

function sumOfInts(int ...$ints)
{
  return array_sum($ints);
}

var_dump(sumOfInts(2, '3', 4.1));

// PHP Fatal error:  Uncaught TypeError: sumOfInts():
//      Argument #2 must be of type int, string given,
//      called in app.php on line 10 and defined in
//      app.php:4
//
// Stack trace:
//  #0 app.php(10): sumOfInts(2, '3', 4.1)
//  #1 {main}
//  thrown in app.php on line 4
```

이런 동작 방식은 반환 타입 선언에도 적용된다. 엄격 모드는 실행하는 파일 기준으로 적용된다. 즉, 엄격 모드가 선언된 파일에서 엄격 모드로 선언하지 않은 파일을 불러와 함수를 호출하면 엄격 모드로 동작한다. [타입 선언 문서](https://www.php.net/manual/en/language.types.declarations.php).

```php
// // util.php
function sumOfInts(int ...$ints)
{
  return array_sum($ints);
}

// // app.php
declare(strict_types=1);
require_once __DIR__.'/util.php';
var_dump(sumOfInts(2, '3', 4.1));

// Fatal error: Uncaught TypeError: sumOfInts(): Argument #2
//         must be of type int, string given, called in
//         app.php on line 4 and defined in util.php:2
//
// Stack trace:
// #0 app.php(4): sumOfInts(2, '3', 4.1)
// #1 {main}
//   thrown in util.php on line 2
```

### 반환 타입 선언

```php
function arraySum(array ...$arrays): array
{
  return array_map(function(array $array): int {
    return array_sum($array);
  }, $arrays);
}

var_dump(arraySum([1,2,3], [4,5,6], [7,8,9]));
// array(3) {
//   [0]=>
//   int(6)
//   [1]=>
//   int(15)
//   [2]=>
//   int(24)
// }
```

### `??`: null 병합 연산자

값이 있거나 `null`이 아닌 경우에는 앞에 있는 연산을, 그 외에는 뒤에 있는 연산을 반환한다.

```php
// 이전 방식
$username = isset($_GET['user']) ? $_GET['user'] : 'nobody';
// null 병합 연산자로 동일한 결과
$username = $_GET['user'] ?? 'nobody';

// 연속해서도 사용 가능
$username = $_GET['user'] ?? $_POST['user'] ?? 'nobody';
```

### `<=>`: 우주선 연산자

주어진 a, b 표현식을 비교해서 a < b, a == b, a > b 에 각각 -1, 0, 1 을 반환한다.

```php
// Integers
echo 1 <=> 1; // 0
echo 1 <=> 2; // -1
echo 2 <=> 1; // 1

// Floats
echo 1.5 <=> 1.5; // 0
echo 1.5 <=> 2.5; // -1
echo 2.5 <=> 1.5; // 1

// Strings
echo "a" <=> "a"; // 0
echo "a" <=> "b"; // -1
echo "b" <=> "a"; // 1
```

### `define()`으로 배열 상수 선언 가능

`const`로만 선언 가능했는데 `define()`으로도 가능해졌다.

```php
define('ANIMALS', ['dog', 'cat', 'brid']);
echo ANIMALS[1]; // 'cat'
```

### 익명 클래스

`new class`로 익명 클래스를 선언할 수 있다. 아래 예시는 익명 클래스로 `Logger` 인터페이스를 구현해서 활용하는 예제다. [익명 클래스 문서](https://www.php.net/manual/en/language.oop5.anonymous.php).

```php
interface Logger {
  public function log(string $msg);
}

class Application {
  private $logger;

  public function getLogger(): Logger {
    return $this->logger;
  }

  public function setLogger(Logger $logger) {
    $this->logger = $logger;
  }
}

$app = new Application;
$app->setLogger(new class implements Logger {
  public function log(string $msg) {
    echo $msg;
  }
});

var_dump($app->getLogger());
```

### 유니코드 탈출 문자 문법

`\u{...}` 형태 문자열을 유니코드로 처리한다.

```php
echo "\u{2615}"; // ☕
```

### `Closure::call()`

클로저에 맥락을 주입해야 할 때 사용할 수 있는 간편한 방식이다.

```php
class A { private $x = 1; }
$getX = function () { return $this-> x; };

$a = new A;

// 이전 방식
$getXCB = $getX->bindTo($a, A::class); // 중간 단계의 클로저
echo $getXCB();

// 새 방식
echo $getX->call($a);
```

### `unserialize()`에서 필터링하기

신뢰할 수 있는 데이터만 역직렬화 할 수 있도록 필터가 추가되었다. 코드 삽입 공격을 막는데 도움이 된다.

```php
// 모든 개체를 __PHP_Incomplete_Class 개체로 변환
$data = unserialize($foo, ["allowed_classes" => false]);

// MyClass와 MyClass2를 제외한 모든 개체를 __PHP_Incomplete_Class 개체로 변환
$data = unserialize($foo, ["allowed_classes" => ["MyClass", "MyClass2"]]);

// 기본 동작 방식 (파라미터 없는 것과 동일)
$data = unserialize($foo, ["allowed_classes" => true]);
```

### `IntlChar`: 유니코드 문자 관련 클래스

[IntlChar](https://www.php.net/manual/en/class.intlchar.php) 문서 참조. Intl 확장이 설치되어 있어야 한다.

```php
printf('%x', IntlChar::CODEPOINT_MAX); // 10ffff
echo IntlChar::charName('☕'); // HOT BEVERAGE
var_dump(IntlChar::ispunct('!')); // bool(true)
```

### Expectations

`assert()` 함수의 하위 호환성 강화를 위해 도입된 기능이다. `assert.exception` 설정에 따라서 `assert()`가 실패했을 경우에 예외를 던진다. 특히 예전 API는 문자열을 처리하는데 그쳤지만 이제는 언어 구조로 편입되어 단순히 문자열 검사나 불린 값 평가가 아닌, 제대로 된 표현식 검사가 이뤄진다.

```php
// 예전에는 이랬다... 문자열을 `eval()`로 처리해서 검사
assert("$hello === false", "hello is false...");
```

```php
// ini_set('assert.exception', 0); // default
assert(false, 'Some error message');
// PHP Warning: assert(): False return test failed in app.php on line 2
```

```php
ini_set('assert.exception', 1);
assert(false, 'Some error message');
// PHP Fatal error:  Uncaught AssertionError: Some error message in app.php:2
// Stack trace:
// #0 app.php(2): assert(false, 'Some error mess...')
// #1 {main}
//   thrown in app.php on line 2
```

별도의 에러도 가능하다.

```php
ini_set('assert.exception', 1);
class CustomError extends AssertionError {}

assert(false, new CustomError('some error message'));
// PHP Fatal error:  Uncaught CustomError: Some error message in app.php:4
// Stack trace:
// #0 app.php(4): assert(false, 'Some error mess...')
// #1 {main}
//   thrown in app.php on line 4
```

### `use` 선언 모아쓰기

```php
// 이전 방식
use some\namespace\ClassA;
use some\namespace\ClassB;
use some\namespace\ClassC as C;

use function some\namespace\fn_a;
use function some\namespace\fn_b;
use function some\namespace\fn_c;

use const some\namespace\ConstA;
use const some\namespace\ConstB;
use const some\namespace\ConstC;

// 새 방식
use some\namespace\{ClassA, ClassB, ClassC as C};
use function some\namespace\{fn_a, fn_b, fn_c};
use const some\namespace\{ConstA, ConstB, ConstC};
```

### 제너레이터 반환 표현

```php
$gen = (function() {
  yield 1;
  yield 2;

  return 3;
})();

foreach ($gen as $val) {
  echo $val, PHP_EOL;
}
// 1
// 2

echo $gen->getReturn(), PHP_EOL;
// 3
```

제너레이터의 `yield`가 모두 끝난 후 최종적인 반환 값을 받아올 수 있도록 `getReturn()` 메소드가 추가되었다.

### 제너레이터 위임

`yield from`으로 제너레이터 중간에 커서를 위임할 수 있다.

```php
function gen()
{
  yield 1;
  yield 2;
  yield from gen2();
}

function gen2()
{
  yield 3;
  yield 4;
}

foreach (gen() as $val)
{
  echo $val, PHP_EOL;
}
// 1
// 2
// 3
// 4
```

### `intdiv()` 정수 나누기 함수

php에서는 정수를 대상으로 `/` 연산자를 사용하면 소숫점 나누기 결과가 나온다. 정수 나누기에는 새로 소개된 `intdiv()`를 사용하면 된다.

```php
$quotient = intdiv(10, 3); // 몫
$remainder = 10 % 3; // 나머지
$div = 10 / 3; // 나누기

echo $quotient; // 3
echo $remainder; // 1
echo $div; // 3.3333333333333
```

### 세션 옵션

세션 옵션이 ini에 설정되어 있었는데 이제 `session_start()`에서도 지정할 수 있다. [가능한 설정 목록](https://www.php.net/manual/en/session.configuration.php).

```php
session_start([
  'cache_limiter' => 'private',
  'read_and_close' => true,
]);
```

### `preg_replace_callback_array()` 추가

정규표현식에 맞는 경우 해당 콜백을 실행한다. 기존 `preg_replace_callback()`으로 장황하게 작성한 코드를 개선할 수 있다. [문서](https://www.php.net/manual/en/function.preg-replace-callback-array.php).

```php
$subject = 'Aaaaaa Bbb';

preg_replace_callback_array(
  [
    '~[a]+~i' => function ($match) {
      echo strlen($match[0]), ' matches for "a" found', PHP_EOL;
    },
    '~[b]+~i' => function ($match) {
      echo strlen($match[0]), ' matches for "b" found', PHP_EOL;
    }
  ],
  $subject
);
// 6 matches for "a" found
// 3 matches for "b" found
```

### CSPRNG 함수 추가

암호학적으로 안전하며 크로스 플랫폼으로 동작하는 함수가 추가되었다.

- `random_bytes()`
- `random_int()`

### `list()`로 `ArrayAccess` 구현 객체 풀기 가능

보장되지 않던 부분인데 수정되었다.

### 클래스 맴버 접근에 `clone` 가능하도록 추가

```php
(clone $foo)->bar();
```

## 변경/추가된 함수 (일부)

- `dirname()`: `depth` 2번 파라미터로 몇 단계 위 경로를 반환할 지 지정할 수 있다.
- `exec()`, `system()`, `passthru()`: NULL 바이트 보호가 추가되었다.
- `substr()`, `iconv_substr()`: 해당하는 값이 없을 때 빈 문자열을 반환하도록 변경되었다.
- `error_clear_last()`: `error_get_last()`를 비운다.

[변경 전체 목록](https://www.php.net/manual/en/migration70.changed-functions.php), [추가 전체 목록](https://www.php.net/manual/en/migration70.new-functions.php).

## 추가된 클래스/인터페이스 (일부)

- [Reflection](https://www.php.net/manual/en/book.reflection.php)
  - [ReflectionGenerator](https://www.php.net/manual/en/class.reflectiongenerator.php)
  - [ReflectionType](https://www.php.net/manual/en/class.reflectiontype.php)
- Exception Hierachy
  - [Throwable](https://www.php.net/manual/en/class.throwable.php)
  - [Error](https://www.php.net/manual/en/class.error.php)
  - TypeError
  - ParseError
  - AssertionError
  - ArithmeticError
  - DivisionByZeroError

[전체 목록](https://www.php.net/manual/en/migration70.classes.php)

## 그 외 변경사항

### 예약어 제한 완화

문맥적인 fluent 인터페이스 개발이 가능하도록 예약어 제한이 약해졌다. (class는 `ClassName::class` 때문에 여전히 사용할 수 없다.)

```php
// 'new', 'private', 'for' 등 전에 사용하지 못했던 메소드명
Project::new('Project Name')
  ->private()
  ->for('purpose here')
  ->with('username here');
```

### date.timezone 경고 제거

설정되지 않은 경우에 나오던 경고가 제거되었다. 기본값은 UTC다.

# PHP 7.1

## 호환성 문제 있는 변경

### 적은 수의 매개변수로 함수를 호출하는 경우

사용자 정의 함수를 호출할 때, 필요한 매개변수보다 적은 수의 인자로 호출하면 경고 대신 오류 예외가 발생한다.

```php
function hello($param) {}
hello();
// Uncaught ArgumentCountError: Too few arguments to function hello(), 0 passed in...
```

### 스코프 연관 함수의 동적 호출 금지

함수가 다른 함수의 기능을 들여다 보거나 스코프를 수정하는 경우라면 동적 호출하는 과정에서 의미가 모호하거나 불안정할 수 있다.

- assert() - with a string as the first argument
- compact()
- extract()
- func_get_args()
- func_get_arg()
- func_num_args()
- get_defined_vars()
- mb_parse_str() - with one arg
- parse_str() - with one arg

```php
(function () {
  $func = 'func_num_args';
  $func();
})();
// Uncaught Error: Cannot call func_num_args() dynamically in....
```

### 추가된 금지어

클래스명, 인터페이스나 trait 이름 금지어로 다음 단어가 추가되었다.

- void
- iterable

### 숫자 문자열 변경이 과학적 표기법을 준수함

`(int)` 캐스팅, `intval()`, `settype()`, `decbin()`, `decoct()`, `dechex()`에도 동일하게 적용되었다.

### `mt_rand()` 알고리즘 수정

제대로 된 Mersenne Twister 알고리즘으로 동작한다. 기존 잘못된 구현으로 함수를 실행하려면 **MT_RAND_PHP**를 두번째 인자로 전달해서 구동할 수 있다.

### `rand()`는 `mt_rand()`, `srand()`는 `mt_srand()`를 수행

이 변경은 `shuffle()`, `str_shuffle()`, `array_rand()`의 출력에도 영향을 준다.

### ASCII 삭제 제어 문자를 식별자로 사용할 수 없음

`0x7E`를 더 이상 식별자로 사용할 수 없다.

### `error_log`가 `syslog`로 설정된 경우 `syslog`의 오류 레벨 설정을 따름

-

### 불완전한 개체에서 소멸자를 호출하지 않음

불완전한 개체에 대해 소멸자를 호출하지 않도록 변경되었다. 즉, 생성자에서 예외가 발생했을 때 그 개체의 소멸자가 호출되지 않는다.

### `call_user_func()`에 참조 인자 사용

`call_user_func()`에 참조 인자를 사용하는 경우 경고가 표시된다. 경고는 표시되지만 호출 자체는 문제 없이 된다.

### 문자열에서의 빈 인덱스 연산자 지원 제거

예전에는 `$str[] = $x` 처럼 작성하면 말 없이 배열로 변환되었지만 이제는 심각한 오류가 발생한다.

### 문자열에서의 인덱스 연산자

예전에는 말 없이 배열로 변환되었던 동작인데 이제는 문자열 인덱스로 접근해서 값을 배정하는 형식으로 동작한다. 대신에 첫 글자만 사용한다.

```php
$a = '';
$a[10] = 'foo';
var_dump($a);
// Warning:  Only the first byte will be assigned to the string offset in...
// string(11) "          f"
```

### 동일 요소에 대한 정렬 순서

정렬할 때 동일한 요소로 판단되면 그 순서가 어느 것이 먼저 온다는 보장이 없다. 그러므로 동일한 요소가 있는 목록의 경우는 그 결과 순서에 의존적인 코드를 작성해서는 안된다.

### `unserialize()` 함수의 `$options` 중 `allowed_classes`

`unserialize()` 함수를 호출하면서 `$options`의 `allowed_classes`가 `array|bool` 타입이 아니면 `false`를 반환하고 **E_WARNING**이 발생한다.

### `DateTime` 생성 시 마이크로초 반영

이전까지 마이크로초가 제대로 반영되지 않아서 다음과 같은 호출이 거의 `true` 였지만 이제는 `false`를 반환할 가능성이 높아졌다.

```php
new DateTime() ==  new DateTime();
```

### 많은 fatal error가 `Error` 예외로 전환

[전체 목록](https://www.php.net/manual/en/migration71.incompatible.php#migration71.incompatible.fatal-errors-to-error-exceptions).

### 클로저에 `use`에서 제한된 함수명

클로저에 `use` 생성자를 사용할 때 슈퍼 전역 변수나 `$this` 등을 사용하면 에러가 발생한다. 매개변수와 동일한 이름도 오류가 발생한다.

```php
$f = function () use ($_SERVER) {};
// Fatal error:  Cannot use auto-global as lexical variable in...

$f = function () use ($this) {};
// Fatal error:  Cannot use $this as lexical variable in...

$f = function ($param) use ($param) {};
// Fatal error:  Cannot use lexical variable $param as a parameter name in...
```

### JSON 변환

`serialize_precision` 환경 설정으로 double 인코딩 시 정밀도를 지정할 수 있다.

이전에 빈 키를 `_empty_` 프로퍼티로 변환하던 것이 고쳐져서 진짜 빈 키로 지정된다.

```php
var_dump(json_decode(json_encode(['' => 1])));
// object(stdClass)#1 (1) {
//   [""]=>
//   int(1)
// }
```

### 반환 타입이 지정된 경우에 `return;` 금지

반환 타입이 지정된 함수에 `return;`을 사용하면 설령 코드가 해당 반환문에 절대 도착하지 않더라도 **E_COMPILE_ERROR**가 발생한다.

```php
function sayHello(): string {
	if (true) {
		return "Hello";
	}
	return;
}
// Fatal error:  A function with return type must return a value in...
```

## 새 기능

### Nullable 타입

타입 선언에서 반환 값이 타입 개체 또는 null인 경우 `?`를 사용해서 nullable 타입으로 선언할 수 있다.

```php
function getNothingWrong(): string
{
  return null;
}

var_dump(getNothingWrong());
// Uncaught TypeError: getNothing(): Return value must be of type string, null returned in...

function getNothing(): ?string
{
  return null;
}

var_dump(getNothing()); // null
```

```php
function getHello(?string $name): string
{
  return "Hello " . ($name ?? 'stranger') . "!";
}

var_dump(getHello(null)); // "Hello stranger!"
var_dump(getHello('Edward')); // "Hello Edward!"
var_dump(getHello());
// Uncaught ArgumentCountError: Too few arguments to function getHello(), 0 passed in...
```

### Void 함수

반환이 없거나 반환 값이 없는 함수의 경우, 타입 선언에 `void`를 넣을 수 있다. 해당 함수를 변수에 배당하면 `null`이 나오며 별도의 오류는 발생하지 않는다.

```php
function sayHello(): void
{
  echo 'Hello!' . PHP_EOL; // 반환이 없음
}

function sayBye(): void
{
  echo 'Bye!' . PHP_EOL;
  return; // 빈 반환
}

$a = sayHello();
var_dump($a); // null
```

`null` 반환은 `void`에 해당하지 않는다. 다음과 같이 오류가 발생한다.

```php
function saySomething(): void
{
  echo 'Something!' . PHP_EOL;
  return null;
}
// Fatal error:  A void function must not return a value
//    (did you mean "return;" instead of "return null;"?) in...
```

### 배열 분해

`[]` 문법으로 간단하게 배열을 분해할 수 있다.

```php
$data = [
  [1, 'Tom'],
  [2, 'Fred'],
];

// list() 사용
//
list($id1, $name1) = $data[0];

foreach($data as list($id, $name)) {
  // $id, $name
}

// [] 사용
//
[$id1, $name1] = $data[0];

foreach($data as [$id, $name]) {
  // $id, $name
}
```

### 클래스 상수 접근 제한자

클래스 상수에도 접근 제한자를 설정할 수 있게 변경되었다.

```php
class ConstDemo
{
  const PUBLIC_CONST_A = 1;
  public const PUBLIC_CONST_B = 2;
  protected const PROTECTED_CONST = 3;
  private const PRIVATE_CONST = 4;
}
```

### `iterable` 임시 타입

반복에 사용할 수 있는 `iterable` 임시 타입이 추가되었다. `Traversable` 인터페이스를 구현한 개체나 배열을 모두 받는다. (`callable`도 임시 타입 중 하나로 호출 가능한 다양한 타입/형태를 받는 것과 유사하다.)

```php
funciton iterator(iterable $iter) {
  // ...
}
```

### 여러 예외 `catch`로 한번에 다루기

파이프 문자(`|`)로 여러 예외를 한번에 처리할 수 있다.

```php
try {
  // some code
} catch (FirstException | SecondException $e) {
  // 두 예외 모두 처리하기
}
```

### `list()` 키 지원

배열을 분해할 때 키를 지정할 수 있다. `list()`와 `[]` 모두 지원한다.

```php
$data = [
  ['id' => 1, 'name' => 'Hellen'],
  ['id' => 2, 'name' => 'Jane'],
];

// list() 사용
//
list('id' => $id1, 'name' => $name1) = $data[0];
foreach ($data as list('id' => $id, 'name' => $name)) {
  // $id, $name
}

// [] 사용
//
['id' => $id1, 'name' => $name1] = $data[0];
foreach ($data as ['id' => $id, 'name' => $name]) {
  // $id, $name
}
```

### 문자열 음수 오프셋 지원

```php
var_dump("abcdef"[-2]); // e
$str = "Hello";
echo "The last character of '$str' is '$str[-1]'.\n";
// "The last character of 'Hello' is 'o'."
```

### `Closure::fromCallable()`: `callable`을 `Closure`개체로 변환

이 함수로 `callable`을 `Closure` 개체로 변환할 수 있어 좀 더 일관성을 갖출 수 있다.

```php
class ShySpeaker
{
  public function exposeWhisper()
  {
    return Closure::fromCallable([$this, 'whisper']);
  }

  private function whisper($saying)
  {
    echo "'$saying', the speaker whispered.";
  }
}

$privateFunc = (new ShySpeaker)->exposeWhisper();
$privateFunc('dang na gui gui');
// "'dang na gui gui', the speaker whispered."
```

### 비동기 시그널 처리

[문서](https://www.php.net/manual/en/function.pcntl-async-signals.php).

```php
pcntl_async_signals(true); // turn on async signals

pcntl_signal(SIGHUP,  function($sig) {
    echo "SIGHUP\n";
});

posix_kill(posix_getpid(), SIGHUP);
```

## 추가된 함수 (일부)

- `session_create_id()`
- `session_gc()`
- `is_iterable()`

[추가된 함수 전체 목록](https://www.php.net/manual/en/migration71.new-functions.php).

## 변경된 함수 (일부)

- `getopt()`: 3번째 인자를 참조로 넘기면 어디까지 처리했는지 인덱스를 받을 수 있다.
- `getenv()`: 인자 없이 호출하면 전체 값을 배열로 반환한다.
- `get_headers()`: 스트림 맥락을 보낼 수 있다.
- `parse_url()`: 더 제한적으로 동작하고 RFC3986를 지원한다.
- `unpack()`: 세번째 인자로 어디서부터 변환이 시작되었는지 지정할 수 있다.
- `session_start()`: 세션 시작에 실패하면 `false` 반환하도록 변경한다.

[전제 목록](https://www.php.net/manual/en/migration71.changed-functions.php).

## 그 외

- 잘못된 문자열로 산술 연산을 수행하면 **E_WARNING**, **E_NOTICE** 둘 다 발생한다.
- `null`이 허용되는 경우에 `TypeError`가 해당 부분도 알려준다. (e.g. must be blarblar or null)

# PHP 7.2

## 새 기능

### 새 `object` 타입

공변(covariant) 반환 타입과 반공변(contravariant) 매개변수 타이핑에 사용할 수 있는 새 타입 `object`가 소개되었다.

```php
function test(object $obj): object
{
  return new SplQueue();
}

test(new StdClass());
```

### `dl()`: 이름으로 확장 불러오기

[`dl()`](https://www.php.net/manual/en/function.dl.php) 함수로 `.so`, `.dll` 확장을 불러올 수 있다.

### 추상 메소드 오버라이드

확장한 추상 클래스에서 추상 메소드를 오버라이드 할 수 있다.

```php
abstract class A
{
  abstract function test(string $s);
}

abstract class B extends A
{
  // 오버라이드 됨. 대신 매개변수의 반공변성과 반환값의 공변성을 따라야 함.
  abstract function test(string $s): int;
}

class Imp extends B
{
  function test(string $s) : int {
    return 3;
  }
}
```

### `Sodium`이 코어 확장에 포함

현대적인 암호화 라이브러리 `Sodium`이 포함되었다. [문서](https://www.php.net/manual/en/book.sodium.php).

### 매개변수 타입 확장

인터페이스의 메소드를 오버라이드하면서 매개변수 타입 선언을 지우는 것으로 확장할 수 있다. 매개변수가 반공변성을 유지하기 때문에 이 확장은 리스코프 치환 원칙(LSP)를 준수한다.

```php
interface A
{
  public function Test(array $input);
}

class B implements A
{
  public function Test($input){} // 타입을 제거함
}
```

### 네임스페이스에 후행 쉼표(trailing comma) 허용

```php
use Hello\World\{
  Foo,
  Bar,
  Baz
};
```

## 새로운 함수

[문서](https://www.php.net/manual/en/migration72.new-functions.php).

## 호환성 문제 있는 변경

### `number_format()`에서 `-0` 반환 문제 수정

따지고 보면 IEEE 754에는 적합한 표현이지만 사람 눈에 이상해보여서 제거되었다.

```php
var_dump(number_format(-0.01)); // 0
```

### 개체에서 배열 캐스팅에 숫자 키 변환 수정

```php
// array -> object
//
$arr = [0 => 1];
$obj = (object) $arr;
var_dump(
  $obj,
  $obj->{'0'},
  $obj->{0},
);
// object(stdClass)#1 (1) {
//   ["0"]=> // 문자열 키로 처리됨
//   int(1)
// }
// int(1)
// int(1)

// object -> array
$obj = new class {
  public function __construct()
  {
    $this->{0} = 1;
  }
};
$arr = (array)$obj;

var_dump(
  $arr,
  $arr[0],
  $arr['0'],
);
// array(1) {
//   [0]=>    // 정수 키로 처리됨
//   int(1)
// }
// int(1)
// int(1)
```

### `get_class()`에 `null` 넘기는 기능이 없어짐

`null`을 넘기면 현재 맥락에 맞는 클래스명을 반환했는데 이제 단순히 인자 없이 호출하면 된다.

### `count()`로 셀 수 없는 타입을 호출한 경우 경고

```php
var_dump(
  count(null), // NULL은 셀 수 없음
  count(1), // 정수는 셀 수 없음
  count('abc'), // 문자열은 셀 수 없음 (대신 `sizeof()`)
  count(new stdclass), // Countable 구현 안하면 셀 수 없음
  count([1,2]), // 배열을 셀 수 있음
);
```

**참고**: 이후 버전에서는 `TypeError`가 발생하며 값을 반환하지 않는다.

### `__PHP_Incomplete_Class`와 `is_object()`

이전엔 `false`였는데 이제는 `true` 반환한다.

### `array_unique()`

`array_unique()`와 **SORT_STRING**을 사용했을 때 배열을 복사해서 중복을 지우는 방식이었다. 이제는 새로운 배열에 요소를 추가하는 방식으로 변경되었다. 그 결과로 숫자 인덱스의 결괏값이 달라졌다.

# PHP 7.3

## 새 기능

### 배열 분해에서 참조 할당 지원

```php
$d = ['a', [1, 2]];

// [] 사용
[&$a, [$b, &$c]] = $d;
$a = 'c';
echo $d[0]; // "c"

// list() 사용
list(&$a, list($b, &$c)) = $d;
$c = 3;
echo $d[1][1]; // 3
```

### instanceof 연산자에서 리터럴 처리

`instanceof`가 리터럴을 받을 수 있도록 변경되었으며 항상 `false`를 반환한다.

```php
class Hello {}
var_dump('Hello' instanceof Hello); // false
var_dump(new Hello instanceof Hello); // true
```

### `CompileError` 예외 추가

몇 가지 심각 오류를 만들던 컴파일 오류가 `ParseError`에서 파생된 `CompileError`로 변경되었다.

### 호출에서 후행 쉼표 사용 가능

함수와 메소드 모두에서 후행 쉼표를 사용할 수 있다.

```php
hello(
  $a,
  $b,
  $c,
  $d, // 예전에 오류가 나던 부분
);
```

### mbstring 개선

[본문 참조](https://www.php.net/manual/en/migration73.new-features.php#migration73.new-features.mbstring).

## 새로운 함수 (일부)

- `array_key_first()`, `array_key_last()`: 배열의 처음 혹은 마지막 키를 반환한다.
- `gc_status()`: 가비지 컬렉터의 상태를 반환한다.
- [`hrtime()`](https://www.php.net/manual/en/function.hrtime.php): 시스템의 고해상도 시간을 반환한다.
- [`is_countable()`](https://www.php.net/manual/en/function.is-countable.php): Countable 인터페이스를 구현했거나 셀 수 있는 지 확인한다.
- [`net_get_interfaces()`](https://www.php.net/manual/en/function.net-get-interfaces.php): 네트워크 인터페이스 정보를 반환한다.
- [`DateTime::createFromImmutable`](https://www.php.net/manual/en/datetime.createfromimmutable.php): `DateTimeImmutable` 개체에서 `DatTime` 개체를 생성한다.

[전체 목록](https://www.php.net/manual/en/migration73.new-functions.php).

## 호환성 문제 있는 변경

### Heredoc/Nowdoc 종결 표식 해석 변경

```php
$str = <<<FOO
abcdefg
   FOO  // 종결 표식 앞에 들여쓰기가 있으면 오류가 나도록 변경됨
FOO;
```

### `switch` 내에서 `continue` 경고

`switch`에서 `continue`는 `break`와 동일하게 동작하기 때문에 `continue 2`를 의도하고 쓴 것인지 확인하는 경고가 추가되었다.

```php
while ($foo) {
    switch ($bar) {
      case "baz":
         continue;
         // Warning: "continue" targeting switch is equivalent to
         //          "break". Did you mean to use "continue 2"?
   }
}
```

### 정적 프로퍼티 참조 문제 수정

정적 프로퍼티가 공유되어야 하는데 참조 배정을 했을 경우에 공유가 되지 않던 문제가 수정되었다.

```php
class Test {
    public static $x = 0;
}
class Test2 extends Test { }

Test2::$x = &$x;
$x = 1;

var_dump(Test::$x, Test2::$x);
// 이전: int(0), int(1)
// 현재: int(1), int(1)
```

### 배열, 프로퍼티 접근자를 참조로 사용하는 경우 바로 값을 반환하도록 변경

```php
$arr = [1];
var_dump($arr[0] + ($arr[0] = 2));
// 이전: int(4)
// 현재: int(3)
```

```php
$arr = [1];
$ref =& $arr[0];
var_dump($ref + ($arr[0] = 2));
// int(4)
```

현재는 이렇게 동작하긴 하지만 표현식 하나에서 값을 읽고 쓰는 부분에 대한 정의가 존재하지 않는다. 그래서 미래에 다른 결과가 나올 수도 있으므로 더 명확한 방식으로 구현하기를 권한다.

### Traversable의 정수가 아닌 숫자 키로 인자 분해 안되도록 변경

```php
function foo(...$args) {
    var_dump($args);
}
function gen() {
    yield 1.23 => 123;
}
foo(...gen());
// Uncaught Error: Keys must be of type int|string during argument unpacking in...
```

## 더 이상 사용되지 않는 기능 (일부)

- 대소문자 구분 안하는 `define()`: 3번째 인자로 대소문자 구분 안하도록 설정 가능했으나 이제 deprecated 되었다.
- 네임스페이스 내 `assert()`

[전체 목록](https://www.php.net/manual/en/migration73.deprecated.php).

## 그 외 변경점 (일부)

`var_export()`는 이제 더 이상 존재하지 않는 `stdClass::__setState()` 메소드 대신 `(object)`로 캐스팅 하는 방식으로 변경되었다.

`array_push()`와 `arry_unshift()`는 단일 인자로도 호출 가능하도록 변경되었다. `...` 연산자와 함께 사용하는데 편리하도록 개선된 부분이다.

```php
$items = [1, 2, 3];

$pushPayload = [&$items, 4];
array_push(...$pushPayload);

var_dump($items);
// array(4) {
//   [0]=>
//   int(1)
//   [1]=>
//   int(2)
//   [2]=>
//   int(3)
//   [3]=>
//   int(4)
// }
```

[전체 목록](https://www.php.net/manual/en/migration73.other-changes.php).

# PHP 7.4

## 새 기능

### 클래스 타입 프로퍼티

클래스 프로퍼티에도 타입을 지정할 수 있게 되었다. 타입이 맞지 않는 값을 넣으면 `TypeError`가 발생한다.

```php
class user {
  public int $id;
  public string $name;
}

$a = new User();
$a->id = 'test';
// Uncaught TypeError: Cannot assign string to property User::$id of type int in...
```

### 화살표 함수

화살표 함수는 암묵적 값 스코프(implicit by-value scope)를 지원하는 축약 문법이다.

```php
$factor = 10;
$nums = array_map(fn($n) => $n * $factor, [1, 2, 3, 4]);
// [10, 20, 30, 40]
```

### 제한적인 공변 반환 타입과 반공변 인자 타입

```php
class A {}
class B extends A {}

class Producer {
  public function method(): A {}
}
class ChildProducer extends Producer {
  public function method(): B {}
}
```

오토로딩이 사용되는 경우에는 모든 변성을 지원한다. 단일 파일에서 작성하는 경우에는 순환 참조를 하지 않는 경우에만 사용할 수 있다. 참조 전에 미리 선언되어 있어야 하기 때문이다.

### Null 병합 배정 연산자

```php
$array['key'] ??= computeDefault();
// 다음과 유사
if (!isset($array['key'])) {
  $array['key'] = computeDefault();
}
```

### 배열 내 배열 풀기

```php
$parts = ['apple', 'pear'];
$fruits = ['banana', 'orange', ...$parts, 'watermelon'];
// ['banana', 'orange', 'apple', 'pear', 'watermelon']
```

### 숫자 리터럴 구분자

```php
6.674_083e-11; // float
299_792_458;   // decimal
0xCAFE_F00D;   // hexadecimal
0b0101_1111;   // binary
```

### 약한 참조

약한 참조는 프로그래머가 개체가 파괴되더라고 개체에 대한 참조를 유지할 수 있는 기능을 제공한다. [`WeakReference`](https://www.php.net/manual/en/class.weakreference.php) 클래스를 활용한다.

```php
// 약한 참조
$obj = new stdClass;
$weakref = WeakReference::create($obj);
var_dump($weakref->get());
// object(stdClass)#1 (0) {
// }

unset($obj);
var_dump($weakref->get());
// NULL
```

```php
// 참조
$obj = new stdClass;
$ref = & $obj;
var_dump($ref);
// object(stdClass)#1 (0) {
// }

unset($obj);
var_dump($ref);
// object(stdClass)#1 (0) {
// }
// 참조로 인해 개체가 파괴되지 않음
```

### `__toString()`에서 예외 허용

이전에는 예외가 있는 경우에 심각 오류가 발생했는데 이제 예외를 던질 수 있게 변경되었다.

### `mb_str_split()` 추가

`str_split()`과 동일한 역할을 하는 멀티바이트 함수가 추가되었다.

### `strip_tags()`에 태그명 배열 사용

```php
strip_tags($str, '<a><p>');
strip_tags($str, ['a', 'p']); // 동일한 기능
```

### 커스텀 개체 직렬화

다음 두 매직 메소드로 개체의 직렬화와 역직렬화를 제어할 수 있다.

```php
// 반환 배열은 개체에 필요한 모든 상태를 포함
public function __serialize(): array;

// 개체 상태를 제시된 자료 배열을 사용해서 복구함
public function __unserialize(array $data): void;
```

### `array_merge()`, `array_merge_recursive()` 단일 인자로도 호출 가능하도록 변경

`array_push()`와 동일한 이유에서 변경되었다.

```php
array_merge(...$arrays);
```

### `proc_open()` 배열 지원

```php
proc_open(['php', '-r', 'echo "Hello World\n";'], $descriptors, $pipes);

// `redirect`와 `null` 디스크립터도 지원
proc_open($cmd, [1 => ['pipe', 'w'], 2 => ['redirect', 1]], $pipes);
proc_open($cmd, [1 => ['pipe', 'w'], 2 => ['null']], $pipes);
```

## 새로운 클래스/함수 (일부)

- [`ReflectionReference`](https://www.php.net/manual/en/class.reflectionreference.php) 클래스가 추가되었다.
- [`get_mangled_object_vars()`](https://www.php.net/manual/en/function.get-mangled-object-vars.php): 개체/하위 개체의 모든 프로퍼티를 확인할 때 사용한다.

[전체 목록](https://www.php.net/manual/en/migration74.new-functions.php).

## 호환성 문제 있는 변경

### 배열이 아닌 값에 배열 스타일로 접근하면 알림 발생

`null`, `bool`, `int`, `float`, 또는 어떤 리소스든 배열이 아닌 것에 배열처럼 접근하면 **E_WARNING**이 발생한다.

```php
$a = 3;
$a[0];
// Warning: Trying to access array offset on value of type int in...
```

### `get_declared_classes()`와 익명 클래스

더 이상 초기화 되지 않은 익명 클래스는 `get_declared_classes()` 함수에서 반환하지 않는다.

### `fn` 키워드 예약어 지정

화살표 함수로 추가된 이 키워드는 더 이상 함수나 클래스명으로 사용할 수 없다. 메소드나 클래스 상수로는 여전히 사용할 수 있다.

### 파일 끝에 `<?php` 오류 수정

파일 끝에 `<?php`가 있으면 문법 오류가 나던 부분이 수정되었다.

### 비밀번호 알고리즘 상수 변경

이전에는 알고리즘 상수가 정수였는데 `?string`으로 변경되었다.

- **PASSWORD_DEFAULT**: int 1 -> string '2y' (PHP 7.4.0, 7.4.1, 7.4.2에서는 `null`)
- **PASSWORD_BCRYPT**: int 1 -> string '2y'
- **PASSWORD_ARGON2I**: int 2 -> string 'argon2i'
- **PASSWORD_ARGON2ID**: int 3 -> string 'argon2id'

### `htmlentities()`

지원이 부족한 인코딩으로 된 데이터를 처리하는 경우에 알림이 발생한다.

### 일자와 시간

`DateInterval` 개체를 비교하면 항상 `false`를 반환한다.

### `Reflection` 개체의 직렬화 불가

원래 지원하지 않던 부분인데 명시적으로 금지되었다.

## 더 이상 사용되지 않는 기능 (일부)

### 명시적이지 않는 중첩 삼항 연산자

이후 버전에서는 아예 제거되어서 Fatal error가 발생한다.

```php
1 ? 2 : 3 ? 4 : 5;   // deprecated
(1 ? 2 : 3) ? 4 : 5; // ok
1 ? 2 : (3 ? 4 : 5); // ok

// PHP 8+
// Fatal error:  Unparenthesized `a ? b : c ? d : e` is not supported.
//     Use either `(a ? b : c) ? d : e` or `a ? b : (c ? d : e)` in...
```

중간에 있는 경우는 모호하지 않아서 중첩에도 여전히 동작한다.

```php
1 ? 2 ? 3 : 4 : 5; // ok
```

### 배열, 문자열 오프셋 접근에 `{}` 사용 중단

```php
// $var{$idx}; 대신 아래 방식 사용
$var[$idx];
```

### `(real)`과 `is_real()` 중단

대신 `(float)`과 `is_float()`을 사용하기를 권장한다.

### 부모 클래스가 없는데 `parent` 키워드 사용 중단

중단 메시지가 나왔으나 PHP 8+ 에서는 심각 오류가 발생한다.

```php
class Hello {
	public function __construct() {
		parent::__construct();
	}
}
// Fatal error:  Cannot use "parent" when current class scope has no parent in...
```

### `array_key_exists()`를 개체에 사용하기 중단

대신 `isset()` 또는 `property_exists()`를 사용한다.

### `money_format()` 함수 중단

대신 [`NumerFormatter`](https://www.php.net/manual/en/class.numberformatter.php) 기능을 사용한다.

### 리플렉션 관련

#### `ReflectionType::__toString()` 중단

대신 `ReflectionNamedType::getName()`을 사용한다.

#### `ReflectionClass::export()` 메소드 중단

대신 개체가 문자열로 변환된다.

```php
// ReflectionClass::export(Foo::class, false)는 다음에 대응
echo new ReflectionClass(Foo::class), "\n";

// $str = ReflectionClass::export(Foo::class, true)는 다음에 대응
$str = (string) new ReflectionClass(Foo::class);
```

## 그 외

[문서  참고](https://www.php.net/manual/en/migration74.other-changes.php).

# PHP 8.0

## 새 기능

[새 기능 전체 목록](https://www.php.net/manual/en/migration80.new-features.php).

### 명명된 인수(Named arguments) 추가

```php
myFunction(paramName: $value);
array_foobar(array: $value);


function person($name, $age) {
	echo "name: $name, age: $age" . PHP_EOL;
}

// 순서가 바뀌어도 됨
person(age: 72, name: 'Sejong');
// 순서 인자와 명명 인자를 섞어도 됨
person('Sejong', age: 72);

// 인수명을 변수로 넣는 것은 지원하지 않음
function_name($variableStoringParamName: $value);

// 동일한 명명 인자를 쓰면 가장 마지막 인자가 덮어씀
person(name: 'Hana', name: 'Narae'); // $name = 'Narae'
person('Hana', name: 'Narae'); // $name = 'Narae'
```

### 어트리뷰트(Attribute) 추가

코드를 선언할 때 기계가 분석할 수 있는 메타 정보를 추가할 수 있도록 어트리뷰트를 지원한다. 이 어트리뷰트의 정보는 리플렉션 API를 통해서 접근할 수 있다.

```php
#[Attribute]
class Setup {}

class CopyFile {
  // ...
  #[SetUp]
  public function fileExists() {
    // ...
  }
}
```

자세한 내용은 [문서를 확인](https://www.php.net/manual/en/language.attributes.php)한다.

```php
// 사용 예시
#[MyAttribute]
#[\MyExample\MyAttribute]
#[MyAttribute(1234)]
#[MyAttribute(value: 1234)]
#[MyAttribute(MyAttribute::VALUE)]
#[MyAttribute(array("key" => "value"))]
#[MyAttribute(100 + 200)]
class Thing
{
}

#[MyAttribute(1234), MyAttribute(5678)]
class AnotherThing
{
}
```

### 클래스 생성자 시그니처로 프로퍼티 선언하기 (constructor property promotion)

생성자 시그니처에 접근 제한자를 포함하면 해당 시그니처를 사용해서 프로퍼티를 자동 할당해준다. 프로모션은 순서에 영향받지 않는다.

```php
class Point {
	public function __construct(protected int $x, protected int $y = 0) {
	}

	public function print(): void {
		echo "x: $this->x, y: $this->y" . PHP_EOL;
	}
}

$p = new Point(1, 2);
$p->print();
```

### 유니언 타입 (Union type) 추가

`|`를 사용해서 타입을 합집합으로 사용할 수 있다. `T1|T2|...` 방식으로 사용한다.

유니언 타입을 선언할 때 `null` 유니언 타입도 지원한다. 즉 `T1|T2|null` 식으로 nullable 합집합을 만들 수 있다. (`null`은 단독으로 쓸 수 있는 타입은 아니며 여기서만 특수하게 사용 가능하다.)

유니언 타입을 선언할 때 `false` 임시 타입도 지원한다. `true`는 존재하지 않는다. `false|null`, `?false`처럼 사용할 수 없다.

### `match` 표현식 추가

`switch`와 유사하나 `switch`는 `===`으로 검사하는데 반해 `match`는 `==`으로 검사한다. [문서](https://www.php.net/manual/en/control-structures.match.php).

```php
$food = 'cake';

$return_value = match ($food) {
  'apple' => 'This food is an apple',
  'bar' => 'This food is a bar',
  'cake' => 'This food is a cake',
};

var_dump($return_value);
// "This food is a cake"

// 조건 표현에는 값, 변수, 값을 반환하는 함수 등 모두 가능하다.
$expressionResult = match ($condition) {
    1, 2 => foo(),
    3, 4 => bar(),
    default => baz(),
};
```

### `?->` null 안전 연산자 추가

null에 안전하게 프로퍼티와 메소드에 접근할 수 있도록 `?->` 연산자가 추가되었다.

```php
$result = $repository?->getUser(5)?->name;

// 다음과 동일
if (is_null($repository)) {
  $result = null;
} else {
  $user = $repository->getUser(5);
  if (is_null($user)) {
    $result = null;
  } else {
    $result = $user->name;
  }
}
```

### `WeakMap` 클래스 추가

레퍼런스 카운트에 영향을 주지 않고 개체를 키로 사용할 수 있는 `WeakMap` 클래스가 추가되었다. [문서](https://www.php.net/manual/en/class.weakmap.php).

```php
$wm = new WeakMap();

$o = new StdClass;

class A {
    public function __destruct() {
        echo "Dead!\n";
    }
}

$wm[$o] = new A;

var_dump(count($wm));
echo "Unsetting...\n";
unset($o);
echo "Done\n";
var_dump(count($wm));
```

### `ValueError` 클래스 추가

인자 타입에 맞게 값이 전달되었지만 값이 맞는 범위에 들지 않는 경우에 사용할 수 있는 `ValueError` 클래스가 추가되었다.

### 메소드 시그니처에 가변 인자 사용 가능

타입이 호환되는 상황이라면 다음처럼 가변 인자를 사용할 수 있다.

```php
class A {
  public function method(int $many, string $parameters, $here) {}
}
class B extends A {
  public function method(...$everything) {}
}
```

### 지연된 바인딩을 위한 `static` 반환 지원

`self`와 비교해볼 수 있는 키워드로 아래 예제를 참고한다.

```php
class Test {
	public function createSelf(): self {
		return new self();
	}
	public function createStatic(): static {
		return new static();
	}
}

class WorkTest extends Test {
}

$test = new Test;
$self = $test->createSelf();
$static = $test->createStatic();

var_dump($self);
var_dump($static);
// object(Test)#2 (0) {
// }
// object(Test)#3 (0) {
// }

$workTest = new WorkTest;
$workSelf = $workTest->createSelf();
$workStatic = $workTest->createStatic();

var_dump($workSelf);
var_dump($workStatic);
// object(Test)#5 (0) {
// }
// object(WorkTest)#6 (0) {
// }
```

### `Stringable` 인터페이스 추가

`Stringable` 인터페이스가 추가되었다. `__toString()` 메소드가 구현되어 있으면 자동으로 구현된 것으로 처리된다.

```php
class Hello {
	public function __toString() {
		return "Hello";
	}
}

function hey(Stringable $s) {
	echo "YES";
}

hey(new Hello);
```

### `throw`를 표현식에 사용

`throw`를 표현식에도 사용할 수 있다.

```php
$fn = fn() => throw new Exception('Exception in arrow function');
$user = $session->user ?? throw new Exception('Must have user');
```

### 그 외 추가된 부분

- 개체에서도 클래스명을 찾을 수 있다. `$object::class`는 `get_class($object)`와 동일한 결과를 반환한다.
- `new`와 `instanceof`를 표현식과 함께 사용할 수 있다. 예: `new (expression)(...$args)`, `$obj instanceof (expression)`.
- Trait으로 추상 private 메소드도 정의할 수 있다.
- `catch (Exception)`으로 변수를 저장하지 않고도 try catch 할 수 있다.
- `mixed` 타입이 추가되었다. `object|resource|array|string|int|float|bool|null`와 동일하다.
- `str_contains()`, `str_starts_with()`, `str_ends_with()`가 추가되었다.
- `array_diff()`, `array_intersect()`도 첫 인자만 갖고도 실행할 수 있다.

## 호환성 문제 있는 변경

변경점이 많은데 중요하다고 생각되는 것만 아래 정리했다. [전체 목록](https://www.php.net/manual/en/migration80.incompatible.php)을 확인하자.

### 문자열-숫자 비교

숫자와 문자열 비교가 여전히 가능하긴 하지만 조금 달라졌다. 이 변경으로 `0 == "숫자가 아닌 것"`은 `false`로 볼 수 있다.

```php
0 == "0"      // true => true
0 == "0.0"    // true => true
0 == "foo"    // true => false
0 == ""       // true => false
42 == " 42"   // true => true
42 == "42foo" // true => false
```

### 매직 메소드 반환 타입 지정

다음과 같은 시그니처가 필요하다.

```php
__call(string $name, array $arguments): mixed
__callStatic(string $name, array $arguments): mixed
__clone(): void
__debugInfo(): ?array
__get(string $name): mixed
__invoke(mixed $arguments): mixed
__isset(string $name): bool
__serialize(): array
__set(string $name, mixed $value): void
__set_state(array $properties): object
__sleep(): array
__unserialize(array $data): void
__unset(string $name): void
__wakeup(): void
```

### 중복된 메소드를 갖고 있는 trait

중복된 메소드를 갖고 있는 trait은 심각한 오류가 발생한다. 그 전에는 암묵적으로 처리되었다. 이제는 명시적으로 충돌을 해소해야 한다.

```php
trait Hello {
	public function test() {
		echo "Hello test" . PHP_EOL;
	}
}

trait Bye {
	public function test() {
		echo "Bye test" . PHP_EOL;
	}
}

class Person {
	use Hello, Bye {
		Hello::test insteadof Bye; // 명시적으로 어느 클래스를 사용할지 지정
    // Hello::test as protected; // 또는 접근 제한을 변경
		Hello::test as helloTest; // 또는 alias를 지정
    Bye::test as byeTest;
		// Bye::test as private byeTest; // 또는 접근 제한을 변경하며 alias를 지정
	}
}

$a = new Person;
$a->test(); // "Hello test"
$a->helloTest(); // "Hello test"
$a->byeTest(); // "Bye test"
```

### 그 외

- `#[`는 더 이상 주석으로 처리되지 않고 어트리뷰트에 사용된다.
- 메소드 시그니처 불일치로 인한 상속 오류는 심각한 오류로 발생한다. 이전엔 경고만 발생했었다.
- `array_key_exists()`가 삭제되었다.
- 함수에 명시적으로 다른 타입이 적혀 있으나 `null` 타입을 받는다고 선언되지 않은 경우에는 `null`을 받지 않는다. 이전엔 암묵적으로 `null`을 받을 수 있었다.
- 익명 클래스의 이름은 이제 상속 클래스나 구현 인터페이스의 첫번째 이름을 기준으로 생성된다.
- 개체 생성자에서 `exit()`이 호출되어도 소멸자는 호출되지 않는다.
- `{}`로 개체 오프셋 접근이 없어졌다. `[]`를 사용한다.
- `assert()`는 더 이상 문자열을 평가하지 않는다.

그 외에도 변경된 부분이 많다. 전체 목록을 참조한다.

## 더 이상 사용되지 않는 기능 (일부)

### 필수 파라미터 앞에 선언된 기본값은 의미 없어짐

아래 코드에서는 `$b`가 필수로 필요하기 때문에 `$a`의 기본값이 의미가 없다. 다만 `nullable`의 경우는 예외적이다.

```php
function test($a = [], $b) {} // 이전
function test($a, $b) {}      // 이후

function test(A $a = null, $b) {} // 아직 가능함
function test(?A $a, $b) {}       // 추천 방식
```

### `usort`에서 우주선 연산자 사용 권장

대부분 정렬 함수가 `boolean`으로 처리했으나 이제는 경고를 표시한다. `<=>`를 권장한다.

```php
// 다음 코드를
usort($array, fn($a, $b) => $a > $b);
// 다음처럼 사용
usort($array, fn($a, $b) => $a <=> $b);
```

## 이외 변경 사항

[문서 참조](https://www.php.net/manual/en/migration80.other-changes.php).

# PHP 8.1

## 새 기능

### 문자열 키와 함께 배열 분해하기

```php
$arr1 = [1, 'a' => 'b'];
$arr2 = [...$arr1, 'c' => 'd']; // [1, 'a' => 'b', 'c' => 'd']
```

### 인자 분해 후 명명된 인자 지정하기

```php
foo(...$args, named: $arg);
```

### Enumerations 추가

열거형 상수인 enum이 추가되었다. 자세한 내용은 [문서를 참고](https://www.php.net/manual/en/language.enumerations.php)한다.

```php
enum Suit
{
    case Hearts;
    case Diamonds;
    case Clubs;
    case Spades;
}
```

### Fibers 추가

코드의 실행 흐름을 제어할 수 있는 `Fiber` 클래스가 추가되었다. 제너레이터는 스택이 없는 반면에 Fiber는 자체 호출 스택을 갖고 있으며 함수 호출이 복잡하고 중첩되더라도 문제 없이 처리한다. 특히 반환 타입이 제한되어 있는 제너레이터와 다르게 어떤 값이든 반환할 수 있다.

```php
$fiber = new Fiber(function (): void {
   $value = Fiber::suspend('fiber');
   echo "다시 시작된 fiber에서 반환된 값: ", $value, PHP_EOL;
});

$value = $fiber->start();

echo "중단된 fiber에서 반환된 값: ", $value, PHP_EOL;

$fiber->resume('test');

// 중단된 fiber에서 반환된 값: fiber
// 다시 시작된 fiber에서 반환된 값: test
```

### `myFunc(...)` callable 문법 추가

`myFunc(...)`은 `Closure::fromCallable('myFunc')`와 동일하다. `...`은 이 문법의 일부이지 줄임표를 쓴 것이 아니다. (처음엔 이상하게 보이더라도 문자열로 된 `callable`을 사용하던 걸 생각하면 훨씬 나은 접근이다.)

```php
$a = [1, 2, 3, 4];
function filter_odd($number) {
  return $number % 2 === 0;
}

$r = array_filter($a, filter_odd(...));
var_dump($r);
// [2, 4]
```

### 교집합(intersection) 타입 추가

`&`를 사용해 교집합 타입을 만들 수 있다. `T1&T2&...`. 합집합 타입과 함께 사용할 수 없다.

### Never 타입

새로운 반환 타입으로 `never`가 추가되었다. 이 타입은 `exit()`이 실행되거나, 예외가 발생하거나, 아니면 종료되지 않아야 한다.

```php
function done(): never {}
done();
// Uncaught TypeError: done(): never-returning function must not implicitly return in...

function done(): never {
  return;
}
done();
// Fatal error: A never-returning function must not return in...

function done(): never {
  exit;
}
done();
```

### `new ClassName()` 허용 추가

파라미터 기본값, 정적 변수, 전역 상수 초기화, 어트리뷰트 인자 등에 `new ClassName()`을 사용할 수 있다.

```php
class School {
	public function __construct(protected string $name) {}
}

class HogwartsStudent {
	public function __construct(
		public string $name,
		public School $school = new School('Hogwarts'),
	) {}
}

$a = new HogwartsStudent(name: 'Harry');
var_dump($a);
// object(HogwartsStudent)#1 (2) {
//   ["name"]=>
//   string(5) "Harry"
//   ["school"]=>
//   object(School)#2 (1) {
//     ["name":protected]=>
//     string(8) "Hogwarts"
//   }
// }
```

이렇게 작성하면 오류가 발생한다.

```php
class HogwartsStudent {
	public School $school = new School('Hogwarts');

	public function __construct(
		public string $name,
	) {}
}
// Fatal error:  New expressions are not supported in this context in...
```

### `readonly` 프로퍼티 추가

개체 초기화에만 작성할 수 있는 `readonly` 프로퍼티가 추가되었다. 타입이 지정된 프로퍼티에만 사용할 수 있다. 정적 클래스에서는 지원하지 않는다.

```php
class Test {
   public readonly string $prop;

   public function __construct(string $prop) {
       // 초기화
       $this->prop = $prop;
   }
}

$test = new Test("foobar");
var_dump($test->prop); // string(6) "foobar"

// 어떤 값이든 다시 배정할 수 없다.
$test->prop = "foobar";
// Error: Cannot modify readonly property Test::$prop
```

```php
class School {
	public function __construct(public readonly string $name) {}
}

$a = new School('MySchool');
var_dump($a);
// object(School)#1 (1) {
//   ["name"]=>
//   string(8) "MySchool"
// }

$a->name = 'MySchool';
// Uncaught Error: Cannot modify readonly property School::$name in...
```


### `final` 클래스 상수 지원

```php
class Foo
{
    final public const X = "foo";
}

class Bar extends Foo
{
    public const X = "bar";
}
// Fatal error: Bar::X cannot override final constant Foo::X
```

## 새로운 함수 (일부)

- `array_is_list()`: 배열이 리스트인지 검증하는 함수다. (associative 배열도 존재하기 떄문에)

[전체 목록](https://www.php.net/manual/en/migration81.new-functions.php).


## 호환성 문제 있는 변경

[전체 목록](https://www.php.net/manual/en/migration81.incompatible.php).

### `$GLOBALS` 접근 제한

배열 내에 있는 값에 대한 읽기/쓰기도 되고 `$GLOBALS`를 읽는 것도 가능하지만 이 배열에 직접 요소를 추가하는 것은 더 이상 불가능하다.

```php
$GLOBALS['hello'] = 'hey';
echo $GLOBALS['hello']; // "hey"

$GLOBALS[] = 'hello';
// Fatal error: Cannot append to $GLOBALS in...
```

### 상속된 메소드에서의 `static` 변수 사용

`static` 변수로 선언하면 상속 트리 내에서 해당 변수가 공유된다.

```php
class StaticCounter {
	public static function count() {
		static $Staticcounter = 0;
		$Staticcounter++;
		return $Staticcounter;
	}
}

class SomeStaticCounter extends StaticCounter {}

var_dump(StaticCounter::count()); // int(1)
var_dump(StaticCounter::count()); // int(2)
var_dump(SomeStaticCounter::count()); // int(3)
var_dump(SomeStaticCounter::count()); // int(4)
var_dump(StaticCounter::count()); // int(5)
```

```php
class Counter {
	public function count() {
		static $counter = 0;
		$counter++;
		return $counter;
	}
}

class SomeCounter extends Counter {}

$a = new Counter;
$b = new SomeCounter;
var_dump($a->count()); // int(1)
var_dump($a->count()); // int(2)
var_dump($b->count()); // int(3)
var_dump($b->count()); // int(4)
var_dump($a->count()); // int(5)
```

### 필수 파라미터를 옵션 파라미터 뒤에 선언

다음처럼 필수 파라미터를 뒤에 선언한 경우 안내가 나온다.

```php
function makeyogurt($container = "bowl", $flavour)
{
  return "Making a $container of $flavour yogurt.\n";
}
// Deprecated: Optional parameter $container declared before
//     required parameter $flavour is implicitly treated as
//     a required parameter in...
```

이런 함수를 호출하면 `ArgumentCountError` 예외가 발생한다.

## 더 이상 사용되지 않는 기능 (일부)

[전체 목록 보기](https://www.php.net/manual/en/migration81.deprecated.php).

### `__serialize()`, `__unserialize()` 없는 `Serializable` 인터페이스 구현 중단

이전 버전의 PHP만 지원하기 위한 경우를 제외하고는 모두 구현해야 한다.

### `null`을 받을 수 없는 내장 함수에 `null` 사용 중단

내장 함수의 스카라 타입은 기본적으로 `null`을 받을 수 있도록 구현되어 있지만 명시적으로 지정되지 않는 이상 중단한다.

```php
var_dump(str_contains("foobar", null));
// Deprecated: Passing null to parameter #2 ($needle) of type string
//             is deprecated
```

### float 배열 키에 대한 묵시적 int 변환 중단

```php
$a = [];
$a[15] = 'a';
echo $a[15.5]; // deprecated, 묵시적 int 변환으로 0.5 잃고 15를 찾긴 함.
// 'a'
echo $a[15.0]; // ok, as 15.0 == 15
// 'a'
```

### `void` 함수의 참조 반환 중단

```php
function &test(): void {}
// Deprecated: Returning by reference from a void function is deprecated in...
```

### `false`의 오토비비피케이션(Autovivification) 중단

오토비비피케이션은 배열로 알아서 생성해주는 기능인데 `false`는 더 이상 되지 않을 예정이다.

```php
$arr = false;
$arr[] = 2;
// Deprecated: Automatic conversion of false to array is deprecated in...

// Undefined나 null에 대해서는 여전히 가능
$arr2[] = 'some value';
$arr2['doesNotExist'][] = 3;

$arr3 = null;
$arr3[] = 2;
```
