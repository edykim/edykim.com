---
title: "PHP 변경점 정리: 5.6부터 8.1까지"
author: haruair
type: post
date: "2022-06-25T18:37:08.736Z"
lang: ko
tags:
 - 개발 이야기
 - php
slug: "php-changes-from-5.6-to-8.1"
draft: true
---

# PHP 5.6

## 엄격해진 `json_decode()`

`json_decode()`에서 소문자가 아닌 `true`, `false`, `null` JSON 리터럴을 사용한 경우에는 오류가 발생하도록 변경되었다. 오류는 `json_last_error()`로 확인 가능하다.

```php
$json = '{
  "is_available": TRUE
}';
$response = json_decode($json);

json_last_error() === JSON_ERROR_SYNTAX; // true
```

## 상수(constant) 표현식

숫자나 문자열 리터럴, 배열을 상수로 정의할 수 있다.

```php
const ONE = 1;
const TWO = ONE * 2;
const ARR = [ONE, TWO];

class C {
    const THREE = TWO + 1;
    const ONE_THIRD = ONE / self::THREE;
    const SENTENCE = 'The value of THREE is ' . self::THREE;

    public function f($a = ONE + self::THREE) {
        echo self::SENTENCE;
        return $a;
    }
}

echo (new C)->f(); // 4
echo C::SENTENCE; // 'The value of THREE is 3'
var_dump(ARR); // [1, 2]
```

개체도 사용할 수 있다.

```php
class Person {
    // ...
}
const ME = new Person('Edward');
var_dump(ME);
// object(Person)#1 (1) {
//   ["name":protected]=>
//   string(6) "Edward"
// }

ME = new Person('Yong');
// Parse error: syntax error, unexpected token "="
```

## `...` 연산자 (operator)

### 함수에서 가변 인자 목록 받기

```php
function school($name, $location = null, ...$students) {
    printf('$name: %s, $location: %s, number of students: %d',
        $name, $location, count($students));
}

school('Hogwarts School', 'Scotland', 'Harry', 'Ron', 'Hermione');
// $name: Hogwarts School, $location: Scotland, number of students: 3
```

### 인자 풀어넣기

배열이나 `Traversable` 개체를 대상으로 인자를 풀어놓을 때 `...` 연산자를 사용할 수 있다. (다른 언어에서는 splat 연산자로 지칭) 이런 문제는 `call_user_func_array()` 같은 함수로 해결했었는데 더 간단하고 깔끔하게 작성할 수 있게 되었다.

```php
function add($a, $b, $c) {
    return $a + $b + $c;
}

$nums = [2, 3];
echo add(1, ...$nums); // 6
```

## `**` 연산자로 거듭제곱하기

```php
$a = 2 ** 3; // 8
$b = 2;
$b **= 2; // 4
```

다음 연산 순서를 주의하자.

```php
$a = 2 ** 3 ** 2;
$b = (2 ** 3) ** 2;
$c = 2 ** (3 ** 2);
// $a: 512
// $b: 64
// $c: 512
```

## `use function`, `use const`

함수나 상수도 `use` 연산자로 불러 사용할 수 있다.

```php
namespace Hello\App {
    const NAME = 'hello';
    function study() { echo __FUNCTION__; }
}

namespace {
    use const Hello\App\NAME;
    use function Hello\App\study;

    echo NAME; // 'hello'
    study(); // 'Hello\App\study'
}
```

## 기본 문자열 인코딩

`htmlentities()`, `html_entity_decode()`, `htmlspecialchars()` 함수에서 기본 문자열 인코딩을 php.ini에 `default_charset` 값을 사용한다. 해당 설정은 `UTF-8`이 기본값이다.

## `hash_equals()` 시간 차 공격에 안전한 문자열 비교 함수

```php
$expected = crypt('some-password', 'some-unsafe-salt');
$correct = crypt('some-password', 'some-unsafe-salt');
$incorrect = crypt('some-wrong-password', 'some-unsafe-salt');

hash_equals($expected, $correct); // true
hash_equals($expected, $incorrect); // false
```

비밀번호 관련 함수를 사용할 수 있다면 다음처럼 작성하는 것을 권장한다.

```php
$hash = password_hash('some-password', PASSWORD_DEFAULT);

password_verify('some-password', $hash); // true
password_verify('some-wrong-password', $hash); // false
```

참고로 `password_verify()` 함수는 `crypt()` 함수의 반환값과도 사용할 수 있다.

## `__debugInfo()` 매직 메소드

클래스에 `__debugInfo()`를 정의하면 `var_dump()` 출력을 제어할 수 있다.

```php
class Person {
  private $name;
  private $secret;

  public function __construct($name, $secret) {
    $this->name = $name;
    $this->secret = $secret;
  }

  public function __debugInfo() {
    return [
      'name' => $this->name,
      'secret' => '****',
    ];
  }
}

$ed = new Person('Edward', 'have a national treasure');

var_dump($ed);
// object(Person)#1 (2) {
//   ["name"]=>
//   string(6) "Edward"
//   ["secret"]=>
//   string(4) "****"
// }
```

## 함수 변경점

- `crypt()` 함수 호출 시 `salt` 파라미터가 누락되면 **E_NOTICE**가 발생.
- `substr_compare()`에 `length` 파라미터로 `0`을 넣을 수 있음.
- `unserialize()` 함수 호출 시 생성자 호출 이전에 직렬화된 데이터를 조작한 시도가 있는 경우 직렬화에 실패하게 됨.

# PHP 7.0

## 오류/예외 처리 변경

많은 수의 심각한 오류(fatal error)가 예외 처리 형태로 변경되었다. 이 오류 예외는 `Error` 클래스를 상속하며 `Throwable` 인터페이스를 구현하고 있다. 직접 구현한 핸들러가 `Exception`만 받도록 되어 있다면 `Error`를 처리하지 못해서 심각한 오류가 발생할 수 있다.

### `set_exception_handler()`

`Throwable` 인터페이스를 활용할 수 있다. 호환성을 고려한다면 타입 선언을 제외한다.

```php
// Will break because of `Error`
function handler(Exception $e) { /* ... */ }
set_exception_handler('handler');

// PHP 5 and 7 compatible.
function handler($e) { /* ... */ }

// PHP 7 only.
function handler(Throwable $e) { /* ... */ }
```

### `ParseError`

`eval()` 함수에서 오류가 발생한 경우 `ParseError`를 `catch`로 잡아서 처리할 수 있게 되었다.

## 변수 사용 변경점

PHP 7부터 abstract syntax tree를 사용하고 있어서 이전에 불가능한 문법을 많이 구현할 수 있게 되었다. 대신 일관성을 유지하기 위해 몇 가지 해석이 달라지는 부분도 생겼다.

| 표현식 | PHP 5 해석 | PHP 7 해석 |
|-|-|-|
| `$$foo['bar']['baz']` | `${$foo['bar']['baz']}` | `($$foo)['bar']['baz']` |
| `$foo->$bar['baz']` | `$foo->{$bar['baz']}` | `($foo->$bar)['baz']` |
| `$foo->$bar['baz']()` | `$foo->{$bar['baz']}()` | `($foo->$bar)['baz']()` |
| `Foo::$bar['baz']()` | `Foo::{$bar['baz']}()` | `(Foo::$bar)['baz']()` |

이전과 같은 방식으로 동작하려면 `{}`를 사용해서 의미를 더 명확하게 작성해야 한다.

## `list()` 변경점

`list()` 함수는 원래 역순으로 입력했는데 이제 순서대로 입력된다. 다만 `list()` 함수의 세부 구현이 변경될 가능성이 있기 때문에 이 함수로 생성한 순서의 의존하는 구현은 권하지 않는다.

```php
list($a[], $a[], $a[]) = [1, 2, 3];
var_dump($a); // [1, 2, 3]
```

